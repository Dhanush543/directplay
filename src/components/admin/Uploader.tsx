// src/components/admin/Uploader.tsx
"use client";

import * as React from "react";

/**
 * Lightweight, dependencyâ€‘free uploader for Admin Media Library.
 * Works with our presign API:
 *   1) POST /api/admin/sign-upload  -> { url: string, fields: Record<string,string>, maxSize?: number }
 *   2) Direct POST to `url` with returned `fields` + file (S3/R2 compatible form POST)
 *   3) POST /api/admin/media        -> finalize record in DB
 *
 * Props let you optionally attach the uploaded media to a course or lesson.
 */

export type UploaderProps = {
    /** Restrict selectable files. E.g. "image/*" or "video/*". */
    accept?: string;
    /** Allow multiple files (default: true). */
    multiple?: boolean;
    /** Optional label shown above the dropzone. */
    label?: string;
    /** Attach uploaded media to a specific course. */
    courseId?: string;
    /** Attach uploaded media to a specific lesson. */
    lessonId?: string;
    /** Called for each successfully created media row. */
    onUploaded?: (media: {
        id: string;
        kind: string;
        key: string;
        url?: string | null;
        width?: number | null;
        height?: number | null;
        sizeBytes?: number | null;
        mime?: string | null;
        createdAt?: string | Date;
    }) => void;
};

/** Internal shape returned by /api/admin/sign-upload */
type PresignResponse = {
    url: string;
    fields: Record<string, string>;
    maxSize?: number;
};

type FileProgress = {
    file: File;
    /** 0..100 */
    pct: number;
    status: "idle" | "signing" | "uploading" | "finalizing" | "done" | "error";
    error?: string | null;
    serverKey?: string; // object key from presigned fields or generated by server
    publicUrl?: string | null;
};

function classNames(...xs: Array<string | false | null | undefined>): string {
    return xs.filter(Boolean).join(" ");
}

export default function Uploader({
    accept,
    multiple = true,
    label = "Upload files",
    courseId,
    lessonId,
    onUploaded,
}: UploaderProps): React.JSX.Element {
    const inputRef = React.useRef<HTMLInputElement | null>(null);
    const [items, setItems] = React.useState<FileProgress[]>([]);
    const [dragOver, setDragOver] = React.useState<boolean>(false);

    const pickFiles = React.useCallback(() => {
        inputRef.current?.click();
    }, []);

    const onFiles = React.useCallback(
        (files: FileList) => {
            const arr = Array.from(files);
            if (arr.length === 0) return;
            const next: FileProgress[] = arr.map((f) => ({
                file: f,
                pct: 0,
                status: "idle",
                error: null,
            }));
            setItems((prev) => [...next, ...prev]);
            // kick off uploads
            void uploadMany(next);
        },
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
    );

    const onInputChange = React.useCallback(
        (e: React.ChangeEvent<HTMLInputElement>) => {
            if (e.target.files) onFiles(e.target.files);
            // reset so selecting the same file again still triggers change
            e.currentTarget.value = "";
        },
        [onFiles]
    );

    const onDrop = React.useCallback(
        (e: React.DragEvent<HTMLDivElement>) => {
            e.preventDefault();
            e.stopPropagation();
            setDragOver(false);
            if (e.dataTransfer.files) onFiles(e.dataTransfer.files);
        },
        [onFiles]
    );

    const preventDefaults = React.useCallback((e: React.DragEvent<HTMLDivElement>) => {
        e.preventDefault();
        e.stopPropagation();
    }, []);

    /** Upload a batch sequentially to keep UI simple and avoid throttling issues. */
    async function uploadMany(batch: FileProgress[]) {
        for (const fp of batch) {
            await uploadSingle(fp).catch(() => {
                /* error state handled inside */
            });
        }
    }

    async function uploadSingle(fp: FileProgress): Promise<void> {
        // 1) presign
        setItems((prev) =>
            prev.map((it) => (it.file === fp.file ? { ...it, status: "signing", pct: 0 } : it))
        );

        let presign: PresignResponse;
        try {
            const res = await fetch("/api/admin/sign-upload", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    filename: fp.file.name,
                    size: fp.file.size,
                    type: fp.file.type,
                    courseId,
                    lessonId,
                }),
            });
            if (!res.ok) {
                throw new Error(await res.text());
            }
            presign = (await res.json()) as PresignResponse;
        } catch (err) {
            const msg = err instanceof Error ? err.message : "Failed to sign upload";
            setItems((prev) =>
                prev.map((it) =>
                    it.file === fp.file ? { ...it, status: "error", error: msg, pct: 0 } : it
                )
            );
            return;
        }

        // 2) direct POST to storage with progress using XHR (needed for progress events)
        setItems((prev) =>
            prev.map((it) => (it.file === fp.file ? { ...it, status: "uploading", pct: 1 } : it))
        );

        const form = new FormData();
        Object.entries(presign.fields).forEach(([k, v]) => form.append(k, v));
        form.append("file", fp.file);

        const uploadPct = (pct: number) => {
            setItems((prev) =>
                prev.map((it) => (it.file === fp.file ? { ...it, pct } : it))
            );
        };

        let publicUrl: string | null = null;
        let serverKey: string | undefined = presign.fields["key"] ?? presign.fields["Key"];

        try {
            await xhrPostForm(presign.url, form, uploadPct);
            // S3 usually serves at `${url}/${key}` only if bucket is website/CNAMEd;
            // we rely on finalize API to supply canonical URL & DB row.
        } catch (err) {
            const msg = err instanceof Error ? err.message : "Upload failed";
            setItems((prev) =>
                prev.map((it) =>
                    it.file === fp.file ? { ...it, status: "error", error: msg, pct: 0 } : it
                )
            );
            return;
        }

        // 3) finalize in DB
        setItems((prev) =>
            prev.map((it) =>
                it.file === fp.file ? { ...it, status: "finalizing", pct: 100, serverKey, publicUrl } : it
            )
        );

        try {
            const finalizeRes = await fetch("/api/admin/media", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    key: serverKey,
                    mime: fp.file.type,
                    sizeBytes: fp.file.size,
                    // let the server infer image/video and fill width/height if available
                    courseId,
                    lessonId,
                }),
            });

            if (!finalizeRes.ok) {
                throw new Error(await finalizeRes.text());
            }

            const media = (await finalizeRes.json()) as {
                id: string;
                kind: string;
                key: string;
                url?: string | null;
                width?: number | null;
                height?: number | null;
                sizeBytes?: number | null;
                mime?: string | null;
                createdAt?: string | Date;
            };

            setItems((prev) =>
                prev.map((it) =>
                    it.file === fp.file ? { ...it, status: "done", publicUrl: media?.url ?? null } : it
                )
            );
            if (onUploaded) onUploaded(media);
        } catch (err) {
            const msg = err instanceof Error ? err.message : "Finalize failed";
            setItems((prev) =>
                prev.map((it) =>
                    it.file === fp.file ? { ...it, status: "error", error: msg } : it
                )
            );
        }
    }

    return (
        <div className="w-full">
            {label && <div className="mb-2 text-sm font-medium text-slate-700">{label}</div>}

            <div
                onDragEnter={(e) => {
                    preventDefaults(e);
                    setDragOver(true);
                }}
                onDragOver={preventDefaults}
                onDragLeave={(e) => {
                    preventDefaults(e);
                    setDragOver(false);
                }}
                onDrop={onDrop}
                className={classNames(
                    "flex cursor-pointer items-center justify-center rounded-2xl border-2 border-dashed px-4 py-10 text-center transition",
                    dragOver ? "border-violet-400 bg-violet-50/40" : "border-slate-300 hover:bg-slate-50"
                )}
                onClick={pickFiles}
                role="button"
                tabIndex={0}
                onKeyDown={(e) => {
                    if (e.key === "Enter" || e.key === " ") pickFiles();
                }}
                aria-label="Upload files"
            >
                <div>
                    <div className="text-sm text-slate-700">
                        Drag and drop files here, or <span className="font-semibold underline">browse</span>
                    </div>
                    {accept && <div className="mt-1 text-xs text-slate-500">Allowed: {accept}</div>}
                </div>
            </div>

            <input
                ref={inputRef}
                type="file"
                className="hidden"
                accept={accept}
                multiple={multiple}
                onChange={onInputChange}
            />

            {items.length > 0 && (
                <ul className="mt-4 space-y-2">
                    {items.map((it) => (
                        <li
                            key={`${it.file.name}-${it.file.size}-${it.file.lastModified}`}
                            className="rounded-xl border border-slate-200 bg-white p-3"
                        >
                            <div className="flex items-center justify-between gap-3">
                                <div className="min-w-0">
                                    <div className="truncate text-sm font-medium text-slate-900">
                                        {it.file.name}
                                    </div>
                                    <div className="mt-0.5 text-xs text-slate-500">
                                        {(it.file.size / (1024 * 1024)).toFixed(2)} MB â€¢ {it.file.type || "unknown"}
                                    </div>
                                </div>
                                <div className="text-xs text-slate-600">
                                    {it.status === "error" ? (
                                        <span className="text-red-600">Error: {it.error ?? "Upload failed"}</span>
                                    ) : it.status === "done" ? (
                                        <span className="text-emerald-700">Uploaded</span>
                                    ) : (
                                        <span className="text-slate-600 capitalize">{it.status}</span>
                                    )}
                                </div>
                            </div>

                            <div className="mt-2 h-2 overflow-hidden rounded bg-slate-100">
                                <div
                                    className={classNames(
                                        "h-full transition-all",
                                        it.status === "error" ? "bg-red-400" : "bg-slate-700"
                                    )}
                                    style={{ width: `${Math.max(2, Math.min(100, Math.round(it.pct)))}%` }}
                                />
                            </div>

                            {it.publicUrl && (
                                <div className="mt-2 truncate text-xs text-slate-500">
                                    URL: <span className="font-mono">{it.publicUrl}</span>
                                </div>
                            )}
                            {it.error && it.status === "error" && (
                                <div className="mt-2 text-xs text-red-700">{it.error}</div>
                            )}
                        </li>
                    ))}
                </ul>
            )}
        </div>
    );
}

/**
 * POST a multipart/form-data using XMLHttpRequest to capture upload progress.
 * Resolves when status is 2xx, otherwise rejects with an Error containing response text.
 */
function xhrPostForm(url: string, form: FormData, onProgress?: (pct: number) => void): Promise<void> {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open("POST", url);
        xhr.upload.onprogress = (evt: ProgressEvent<EventTarget>) => {
            if (!evt.lengthComputable) return;
            const pct = (evt.loaded / (evt.total || 1)) * 100;
            if (onProgress) onProgress(pct);
        };
        xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve();
            } else {
                const msg = xhr.responseText || `HTTP ${xhr.status}`;
                reject(new Error(msg));
            }
        };
        xhr.onerror = () => reject(new Error("Network error"));
        xhr.send(form);
    });
}
